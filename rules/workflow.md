# Workflow разработки (VLMHyperBench)

## Workflow разработки (Playground -> Production)

### 1. Этап Playground (Прототипирование)
*   **Где**: Текущий репозиторий `vlmhyperbench_playground`.
*   **Что делаем**:
    *   Реализуем базовые абстрактные классы и компоненты ядра.
    *   Код пишется в режиме `dev` (editable packages).

### 2. Этап Integration (Подключение модулей)
*   **Что делаем**:
    *   Используем **динамическую композицию** вместо Git Submodules.
    *   Пакеты плагинов (датасеты, метрики, **адаптеры инференса**) живут в независимых репозиториях.
    *   Для разработки в `dev` режиме клонируем репозиторий пакета в любую локальную папку (обычно `packages/`) и прописываем путь в `.dev.yaml` оверлее реестра.
    *   Оркестратор автоматически устанавливает такие пакеты в **editable** режиме (`pip install -e`) в рантайме.
    *   **Важно**: Мы НЕ используем `uv workspaces` в корневом проекте для изоляции зависимостей. Каждый пакет автономен.

## Работа с зависимостями (uv)
*   **RUN_MODE**:
    *   `RUN_MODE=dev`: Используются локальные пути из `.dev.yaml` оверлеев.
    *   `RUN_MODE=prod`: Используются стабильные версии из базовых `.yaml` файлов.

### 3. Этап Pipeline & Testing
*   **Что делаем**:
    *   Прогоняем полный пайплайн (Inference -> Eval -> Report) на тестовых данных.
    *   Исправляем баги как в ядре, так и в подключаемых модулях.

### 4. Этап Release (Фиксация версий)
*   **Что делаем**:
    *   **Для новых пакетов**:
        *   Создаем независимый репозиторий в GitHub организации [VLMHyperBenchTeam](https://github.com/VLMHyperBenchTeam) с помощью **GitHub MCP Server**.
        *   Инициализируем локальный Git-репозиторий внутри папки пакета (`git init`).
        *   Добавляем удаленный репозиторий (`git remote add origin ...`) и пушим код в ветку `main`.
    *   **Для обновлений**: Заводим новую ветку, пушим изменения, проводим тестирование. После готовности создаем **Pull Request (PR)** с описанием изменений.
    *   **Версионирование**: После слияния PR создаем **git tags** (например, `v0.1.0`).
    *   В YAML-реестрах обновляем ссылки на конкретные теги (`type: git, ref: v0.1.0`).
    *   Это гарантирует 100% воспроизводимость экспериментов в `prod` режиме.

## Работа с индексом кода (Code Index)
*   Используйте `refresh_index` и `build_deep_index` для поддержания актуальности базы знаний.
*   **Важно**: Выполняйте полную инициализацию индекса (см. [`memory_bank.md`](.kilocode/rules/memory_bank.md)) в начале каждой новой задачи.

## Обновление базы знаний (Memory Bank)
*   После успешного завершения задачи ОБЯЗАТЕЛЬНО обновляйте соответствующие файлы в `.kilocode/rules/`.