# Правила разработки (v0.2.0)

Отвечай на русском языке.

## Принципы архитектуры
1.  **Async-First**: Все сетевые вызовы (API Wrapper, DB, WebSockets) должны быть асинхронными.
2.  **BFF (Backend for Frontend)**: API сервер подготавливает данные для визуализации (Plotly JSON) на стороне бэкенда.
3.  **Strict Validation**: Любой структурированный вывод модели должен валидироваться через Pydantic.

## Workflow разработки (Playground -> Production)

Мы используем итеративный подход к разработке, начиная с прототипирования в `playground` и заканчивая фиксацией стабильных версий пакетов.

### 1. Этап Playground (Прототипирование)
*   **Где**: Текущий репозиторий `vlmhyperbench_playground`.
*   **Что делаем**:
    *   Реализуем базовые абстрактные классы и компоненты ядра VLMHyperBench.
    *   Проводим быстрые эксперименты и проверку гипотез.
    *   Код пишется в режиме `dev` (editable packages).
    *   **Legacy скрипты**: Старые тестовые Python-скрипты перенесены в `tmp_model_eval/`. Они не интегрированы с новой системой оркестрации и требуют обновления. Оставлены для истории как источник кода, который может пригодиться в будущем; позже будут либо обновлены, либо удалены.

### 2. Этап Integration (Подключение модулей)
*   **Что делаем**:
    *   Монтируем необходимые репозитории (с реализациями конкретных `Task`, `Model`, `Metric`) как **git submodules** в папку `packages/`.
    *   Пример: `packages/model-qwen2-5-vl`, `packages/bench-utils`.
    *   Разрабатываем реализации для конкретных задач, используя базовые абстракции из ядра.

### 3. Этап Pipeline & Testing
*   **Что делаем**:
    *   Прогоняем полный пайплайн (Inference -> Eval -> Report) на тестовых данных.
    *   Убеждаемся, что все компоненты взаимодействуют корректно.
    *   Исправляем баги как в ядре, так и в подключаемых модулях.

### 4. Этап Release (Фиксация версий)
*   **Что делаем**:
    *   Пушим работающие версии кода в соответствующие удаленные репозитории пакетов.
    *   Создаем git tags (например, `v0.1.0`) в репозиториях пакетов.
    *   В `uv.lock` (для `prod` профиля) фиксируем **точные версии пакетов** (через git tags), совместимые с текущей версией ядра.
    *   Это гарантирует воспроизводимость экспериментов: `prod` окружение собирается из конкретных версий python-пакетов.

## Работа с зависимостями (uv)
*   **dev**: Используем `workspace = true` для разработки.
*   **prod**: Используем ссылки на **git tags** (версии пакетов) для фиксации стабильного состояния.

## Работа с индексом кода (Code Index)

Для эффективной работы с кодовой базой необходимо поддерживать индекс в актуальном состоянии.
*   При возникновении ошибок или если кажется, что информация о файлах устарела, используйте [`refresh_index`](.kilocode/rules/development.md:44) для обновления списка файлов.
*   Для глубокого анализа символов (функций, классов) используйте [`build_deep_index`](.kilocode/rules/development.md:45).
*   Проверить текущие настройки и пути индексации можно через [`get_settings_info`](.kilocode/rules/development.md:46).

## Обновление базы знаний (Memory Bank)

После успешного выполнения задачи, которая вносит изменения в архитектуру, процессы или структуру проекта, необходимо обновлять соответствующие файлы в `.kilocode/rules/`. Это гарантирует, что "память" системы остается актуальной для будущих задач.